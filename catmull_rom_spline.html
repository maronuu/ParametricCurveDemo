<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title id="title">[utokyo-iscg-2023] Basic Assignment M1 (Spline)</title>
    <script src="https://rawcdn.githack.com/toji/gl-matrix/v3.3.0/dist/gl-matrix-min.js"></script>
    <script src="https://bbcdn.githack.com/kenshi84/legacygl.js/raw/master/gl-matrix-util.js"></script>
    <script src="https://bbcdn.githack.com/kenshi84/legacygl.js/raw/master/legacygl.js"></script>
    <script src="https://bbcdn.githack.com/kenshi84/legacygl.js/raw/master/drawutil.js"></script>
    <script src="https://bbcdn.githack.com/kenshi84/legacygl.js/raw/master/camera.js"></script>
    <script src="https://bbcdn.githack.com/kenshi84/legacygl.js/raw/master/util.js"></script>
    <script src="https://bbcdn.githack.com/kenshi84/legacygl.js/raw/master/glu.js"></script>
    <script type="text/javascript">
        var gl;
        var canvas;
        var legacygl;
        var drawutil;
        var camera;
        var p0, p1, p2, p3, p4, p5;
        var selected = null;

        function eval_catmull_rom_spline(ps, t, ts, seg_idx) {
            // ps: control points
            // t: parameter
            // ts: knots
            // seg_idx: segment index (0 <= seg_idx <= n-1)
            if (seg_idx == 0) {
                var p1 = ps[seg_idx];
                var p2 = ps[seg_idx + 1];
                var p3 = ps[seg_idx + 2];
                var t1 = ts[seg_idx];
                var t2 = ts[seg_idx + 1];
                var t3 = ts[seg_idx + 2];

                var p12 = vec2.scaleAndAdd_ip(vec2.scale([], p1, (t2 - t) / (t2 - t1)), p2, (t - t1) / (t2 - t1));
                var p23 = vec2.scaleAndAdd_ip(vec2.scale([], p2, (t3 - t) / (t3 - t2)), p3, (t - t2) / (t3 - t2));

                var p123 = vec2.scaleAndAdd_ip(vec2.scale([], p12, (t3 - t) / (t3 - t1)), p23, (t - t1) / (t3 - t1));

                return p123;
            }
            if (seg_idx == ts.length - 2) {
                var p0 = ps[seg_idx - 1];
                var p1 = ps[seg_idx];
                var p2 = ps[seg_idx + 1];
                var t0 = ts[seg_idx - 1];
                var t1 = ts[seg_idx];
                var t2 = ts[seg_idx + 1];

                var p01 = vec2.scaleAndAdd_ip(vec2.scale([], p0, (t1 - t) / (t1 - t0)), p1, (t - t0) / (t1 - t0));
                var p12 = vec2.scaleAndAdd_ip(vec2.scale([], p1, (t2 - t) / (t2 - t1)), p2, (t - t1) / (t2 - t1));

                var p012 = vec2.scaleAndAdd_ip(vec2.scale([], p01, (t2 - t) / (t2 - t0)), p12, (t - t0) / (t2 - t0));

                return p012;
            }
            var p0 = ps[seg_idx - 1];
            var p1 = ps[seg_idx];
            var p2 = ps[seg_idx + 1];
            var p3 = ps[seg_idx + 2];
            var t0 = ts[seg_idx - 1];
            var t1 = ts[seg_idx];
            var t2 = ts[seg_idx + 1];
            var t3 = ts[seg_idx + 2];

            var p01 = vec2.scaleAndAdd_ip(vec2.scale([], p0, (t1 - t) / (t1 - t0)), p1, (t - t0) / (t1 - t0));
            var p12 = vec2.scaleAndAdd_ip(vec2.scale([], p1, (t2 - t) / (t2 - t1)), p2, (t - t1) / (t2 - t1));
            var p23 = vec2.scaleAndAdd_ip(vec2.scale([], p2, (t3 - t) / (t3 - t2)), p3, (t - t2) / (t3 - t2));

            var p012 = vec2.scaleAndAdd_ip(vec2.scale([], p01, (t2 - t) / (t2 - t0)), p12, (t - t0) / (t2 - t0));
            var p123 = vec2.scaleAndAdd_ip(vec2.scale([], p12, (t3 - t) / (t3 - t1)), p23, (t - t1) / (t3 - t1));

            var p0123 = vec2.scaleAndAdd_ip(vec2.scale([], p012, (t2 - t) / (t2 - t1)), p123, (t - t1) / (t2 - t1));

            return p0123;
        }

        function get_knots_uniform(n) {
            // t_k = t_{k-1} + 1, t_0 = 0
            var knots = [0];
            for (var i = 1; i < n; i++) {
                knots.push(knots[i - 1] + 1);
            }
            return knots;
        }

        function get_knots_chordal(n, ps) {
            // t_k = t_{k-1} + |p_k - p_{k-1}|, t_0 = 0
            var knots = [0];
            for (var i = 1; i < n; i++) {
                knots.push(knots[i - 1] + vec2.distance(ps[i], ps[i - 1]));
            }
            return knots;
        }

        function get_knots_centripetal(n, ps) {
            // t_k = t_{k-1} + |p_k - p_{k-1}|^0.5, t_0 = 0
            var knots = [0];
            for (var i = 1; i < n; i++) {
                knots.push(knots[i - 1] + Math.sqrt(vec2.distance(ps[i], ps[i - 1])));
            }
            return knots;
        }

        function draw() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            // projection & camera position
            mat4.perspective(legacygl.uniforms.projection.value, Math.PI / 6, canvas.aspect_ratio(), 0.1, 1000);
            var modelview = legacygl.uniforms.modelview;
            camera.lookAt(modelview.value);

            // xy grid
            gl.lineWidth(1);
            legacygl.color(0.5, 0.5, 0.5);
            drawutil.xygrid(100);

            // draw line segments composing curve
            // load config
            var numsteps = Number(document.getElementById("input_numsteps").value);
            var numknots = 6;
            // generate knots
            var knots_uniform = get_knots_uniform(numknots);
            var ps = [p0, p1, p2, p3, p4, p5];
            legacygl.color(0, 0.5, 0);
            legacygl.begin(gl.LINE_STRIP);
            for (var i = 1; i <= numknots - 3; ++i) {
                // segment i
                for (var j = 0; j <= numsteps; ++j) {
                    var t = knots_uniform[i] + j * (knots_uniform[i + 1] - knots_uniform[i]) / numsteps;
                    console.log("t = ", t);
                    legacygl.vertex2(eval_catmull_rom_spline(ps, t, knots_uniform, i));
                }
            }
            legacygl.end();
            if (document.getElementById("input_show_samplepoints").checked) {
                legacygl.begin(gl.POINTS);
                for (var i = 1; i <= numknots - 3; ++i) {
                    // segment i
                    for (var j = 0; j <= numsteps; ++j) {
                        var t = knots_uniform[i] + j * (knots_uniform[i + 1] - knots_uniform[i]) / numsteps;
                        legacygl.vertex2(eval_catmull_rom_spline(ps, t, knots_uniform, i));
                    }
                }
                legacygl.end();
            }

            var knots_chordal = get_knots_chordal(numknots, ps);
            legacygl.color(0.8, 0.0, 0.0);
            legacygl.begin(gl.LINE_STRIP);
            for (var i = 1; i <= numknots - 3; ++i) {
                // segment i
                for (var j = 0; j <= numsteps; ++j) {
                    var t = knots_chordal[i] + j * (knots_chordal[i + 1] - knots_chordal[i]) / numsteps;
                    legacygl.vertex2(eval_catmull_rom_spline(ps, t, knots_chordal, i));
                }
            }
            legacygl.end();
            if (document.getElementById("input_show_samplepoints").checked) {
                legacygl.begin(gl.POINTS);
                for (var i = 1; i <= numknots - 3; ++i) {
                    // segment i
                    for (var j = 0; j <= numsteps; ++j) {
                        var t = knots_chordal[i] + j * (knots_chordal[i + 1] - knots_chordal[i]) / numsteps;
                        legacygl.vertex2(eval_catmull_rom_spline(ps, t, knots_chordal, i));
                    }
                }
                legacygl.end();
            }

            var knots_centripetal = get_knots_centripetal(numknots, ps);
            legacygl.color(0.0, 0.0, 1);
            legacygl.begin(gl.LINE_STRIP);
            for (var i = 1; i <= numknots - 3; ++i) {
                // segment i
                for (var j = 0; j <= numsteps; ++j) {
                    var t = knots_centripetal[i] + j * (knots_centripetal[i + 1] - knots_centripetal[i]) / numsteps;
                    legacygl.vertex2(eval_catmull_rom_spline(ps, t, knots_centripetal, i));
                }
            }
            legacygl.end();
            if (document.getElementById("input_show_samplepoints").checked) {
                legacygl.begin(gl.POINTS);
                for (var i = 1; i <= numknots - 3; ++i) {
                    // segment i
                    for (var j = 0; j <= numsteps; ++j) {
                        var t = knots_centripetal[i] + j * (knots_centripetal[i + 1] - knots_centripetal[i]) / numsteps;
                        legacygl.vertex2(eval_catmull_rom_spline(ps, t, knots_centripetal, i));
                    }
                }
                legacygl.end();
            }
            
            // draw control points
            if (document.getElementById("input_show_controlpoints").checked) {
                legacygl.color(0.0, 0.0, 0.0);
                legacygl.begin(gl.LINE_STRIP);
                legacygl.vertex2(p0);
                legacygl.vertex2(p1);
                legacygl.vertex2(p2);
                legacygl.vertex2(p3);
                legacygl.vertex2(p4);
                legacygl.vertex2(p5);
                legacygl.end();
                legacygl.begin(gl.POINTS);
                legacygl.vertex2(p0);
                legacygl.vertex2(p1);
                legacygl.vertex2(p2);
                legacygl.vertex2(p3);
                legacygl.vertex2(p4);
                legacygl.vertex2(p5);
                legacygl.end();
            }
        };
        function init() {
            // OpenGL context
            canvas = document.getElementById("canvas");
            gl = canvas.getContext("experimental-webgl");
            if (!gl)
                alert("Could not initialise WebGL, sorry :-(");
            var vertex_shader_src = "\
        attribute vec3 a_vertex;\
        attribute vec3 a_color;\
        varying vec3 v_color;\
        uniform mat4 u_modelview;\
        uniform mat4 u_projection;\
        void main(void) {\
            gl_Position = u_projection * u_modelview * vec4(a_vertex, 1.0);\
            v_color = a_color;\
            gl_PointSize = 5.0;\
        }\
        ";
            var fragment_shader_src = "\
        precision mediump float;\
        varying vec3 v_color;\
        void main(void) {\
            gl_FragColor = vec4(v_color, 1.0);\
        }\
        ";
            legacygl = get_legacygl(gl, vertex_shader_src, fragment_shader_src);
            legacygl.add_uniform("modelview", "Matrix4f");
            legacygl.add_uniform("projection", "Matrix4f");
            legacygl.add_vertex_attribute("color", 3);
            legacygl.vertex2 = function (p) {
                this.vertex(p[0], p[1], 0);
            };
            drawutil = get_drawutil(gl, legacygl);
            camera = get_camera(canvas.width);
            camera.eye = [0, 0, 6];
            p0 = [-0.3, 0.1];
            p1 = [1.2, -0.7];
            p2 = [1.2, -0.5];
            p3 = [-0.8, 1.3];
            p4 = [-1.2, 0.9];
            p5 = [-1.2, -0.8];
            // event handlers
            canvas.onmousedown = function (evt) {
                var mouse_win = this.get_mousepos(evt);
                if (evt.altKey) {
                    camera.start_moving(mouse_win, evt.shiftKey ? "zoom" : "pan");
                    return;
                }
                // pick nearest object
                var points = [p0, p1, p2, p3, p4, p5];
                var viewport = [0, 0, canvas.width, canvas.height];
                var dist_min = 10000000;
                for (var i = 0; i < points.length; ++i) {
                    var object_win = glu.project([points[i][0], points[i][1], 0],
                        legacygl.uniforms.modelview.value,
                        legacygl.uniforms.projection.value,
                        viewport);
                    var dist = vec2.dist(mouse_win, object_win);
                    if (dist < dist_min) {
                        dist_min = dist;
                        selected = points[i];
                    }
                }
            };
            canvas.onmousemove = function (evt) {
                var mouse_win = this.get_mousepos(evt);
                if (camera.is_moving()) {
                    camera.move(mouse_win);
                    draw();
                    return;
                }
                if (selected != null) {
                    var viewport = [0, 0, canvas.width, canvas.height];
                    mouse_win.push(1);
                    var mouse_obj = glu.unproject(mouse_win,
                        legacygl.uniforms.modelview.value,
                        legacygl.uniforms.projection.value,
                        viewport);
                    // just reuse the same code as the 3D case
                    var plane_origin = [0, 0, 0];
                    var plane_normal = [0, 0, 1];
                    var eye_to_mouse = vec3.sub([], mouse_obj, camera.eye);
                    var eye_to_origin = vec3.sub([], plane_origin, camera.eye);
                    var s1 = vec3.dot(eye_to_mouse, plane_normal);
                    var s2 = vec3.dot(eye_to_origin, plane_normal);
                    var eye_to_intersection = vec3.scale([], eye_to_mouse, s2 / s1);
                    vec3.add(selected, camera.eye, eye_to_intersection);
                    draw();
                }
            }
            document.onmouseup = function (evt) {
                if (camera.is_moving()) {
                    camera.finish_moving();
                    return;
                }
                selected = null;
            };
            // init OpenGL settings
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(1, 1, 1, 1);
        };
    </script>
</head>

<body onload="init(); draw();">
    <h2>
        <script type="text/javascript">document.write(document.getElementById("title").innerHTML);</script>
    </h2>
    <canvas id="canvas" width="640" height="480" style="border:1px solid #000000"></canvas>
    <table>
        <tr>
            <td>Number of Steps per Segment:</td>
            <td colspan="2"><input type="number" id="input_numsteps" onchange="draw();" step="1" min="2" value="10">
            </td>
        </tr>
        <tr>
            <td>Show Control Points:</td>
            <td colspan="2"><input type="checkbox" id="input_show_controlpoints" onchange="draw();" checked></td>
        </tr>
        <tr>
            <td>Show Sample Points:</td>
            <td colspan="2"><input type="checkbox" id="input_show_samplepoints" onchange="draw();" checked></td>
        </tr>
    </table>
    <h3>Usage:</h3>
    <ul>
        <li>Drag: Move Control Points</li>
        <li>Alt+Drag: Camera Pan</li>
        <li>Alt+Shift+drag: Camera Zoom</li>
    </ul>
    <h3>Color:</h3>
    <ul>
        <li style="color:#005500">Green Line: Uniform Knots</li>
        <li style="color:red">Red Line: Chordal Knots</li>
        <li style="color:blue">Blue Line: Centripetal Knots</li>
    </ul>

    <div class="glitchButton" style="position:fixed;top:20px;right:20px;"></div>
    <script src="https://button.glitch.me/button.js"></script>
</body>

</html>